<#@ template language="C#" debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="Common.ttinclude" #>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
<#@ include file="Views.ttinclude" #>

namespace DotNetCross.Memory.Views
{
<#
    const string classNamePrefix = "View";
    for (int dims = 1; dims <= MaxFixedDimensions; ++dims)
    {
        string dimSuffix = dims + "D";
        string type = classNamePrefix + dimSuffix;
        IReadOnlyList<int> indeces = Enumerable.Range(0, dims).ToArray();
        string sameDimArray = "T[" + string.Join("", Enumerable.Repeat(",", dims -1 )) + "]";
        string startIndecesJoined = string.Join(", ", indeces.Select(i => "int start" + i));
        string lengthsJoined = string.Join(", ", indeces.Select(i => "int length" + i));
        string indecesJoined = string.Join(", ", indeces.Select(i => "int index" + i));
        IReadOnlyList<int> byteStrideIndeces = Enumerable.Range(0, dims - 1).ToArray();
        string byteStridesJoined = string.Join(", ", byteStrideIndeces.Select(i => "IntPtr byteStride" + i));
        string lengthsAndByteStridesJoined = dims <= 1 ? lengthsJoined : lengthsJoined + ", " + byteStridesJoined;
  
        string lengthsOnlyJoined = string.Join(", ", indeces.Select(i => "length" + i));
        string byteStridesOnlyJoined = string.Join(", ", byteStrideIndeces.Select(i => "byteStride" + i));
        string lengthsAndByteStridesOnlyJoined = dims <= 1 ? lengthsOnlyJoined : lengthsOnlyJoined + ", " + byteStridesOnlyJoined;
        // TODO: Also add value tuple ctors
#>
    [StructLayout(LayoutKind.Sequential)]
    public readonly partial struct <#= type #><T>
    {
        readonly object _objectOrNull;
        readonly IntPtr _byteOffsetOrPointer;
<#
        for (int dim = 0; dim < dims - 1; ++dim)
        {
#>
        readonly IntPtr _byteStride<#= dim #>;
<#
        }
#>
        // .NET has for good chosen int as size, would have preferred IntPtr e.g. nint
        // for length but this would give issues with interoperating with BCL
<#
        for (int dim = 0; dim < dims; ++dim)
        {
#>
        readonly int _length<#= dim #>;
<#
        }
#>

        public <#= type #>(<#= sameDimArray #> array)
        {
<#
            CtorArrayPreamble(dimSuffix);
            CtorSetLengthsByArray(dims);
            CtorSetByteStridesFromLengths(dims);
#>
        }

        public <#= type #>(<#= sameDimArray #> array, <#= startIndecesJoined #>)
        {
<#
            CtorArrayPreamble(dimSuffix);
            CtorSetLengthsByArray(dims);
            CtorSetByteStridesFromLengths(dims);
            CtorCheckStarts(dims);
            CtorMoveByteOffset(dims);
#>
        }

        public <#= type #>(<#= sameDimArray #> array, <#= startIndecesJoined #>,
            <#= lengthsJoined #>)
        {
<#
            CtorArrayPreamble(dimSuffix);
            CtorSetLengthsByArray(dims);
            CtorSetByteStridesFromLengths(dims);
            CtorCheckStartsAndLengths(dims);
            CtorMoveByteOffset(dims);
            CtorUpdateLengthsToParams(dims);
#>
        }
        public unsafe <#= type #>(void* pointer, <#= lengthsJoined #>)
        {
<#
            CtorPointerPreamble(dimSuffix);
            CtorUpdateLengthsToParams(dims);
            CtorSetByteStridesFromLengths(dims);
#>
        }
<#
        if (dims > 1)
        {
#>
        public unsafe <#= type #>(void* pointer, <#= lengthsJoined #>,
            <#= byteStridesJoined #>)
        {
<#
            CtorPointerPreamble(dimSuffix);
            CtorUpdateLengthsToParams(dims);
            CtorSetByteStrides(dims);
#>
        }
<#
        }
#>

        // Constructor for internal use only.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal <#= type #>(object obj, IntPtr byteOffset, 
            <#= lengthsAndByteStridesJoined #>)
        {
            //Debug.Assert(length >= 0);

            _objectOrNull = obj;
            _byteOffsetOrPointer = byteOffset;
<#
            CtorUpdateLengthsToParams(dims);
            CtorSetByteStrides(dims);
#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#= type #><T> DangerousCreate(object obj, ref T objectData, 
            <#= lengthsAndByteStridesJoined #>)
        {
            if (obj == null)
                ThrowHelper.ThrowArgumentNullException(ExceptionArgument.obj);
<#
            CtorCheckLengthsNotNegative(dims);
#>

            IntPtr byteOffset = Unsafe.ByteOffset(obj, ref objectData);
            return new <#= type #><T>(obj, byteOffset, 
                <#= lengthsAndByteStridesOnlyJoined #>);
        }

<#
        Indexer(indecesJoined, dims);
        UnsafeAt(indecesJoined, dims);
#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T GetPinnableReference()
        {
            return ref Unsafe.RefAtByteOffset<T>(_objectOrNull, _byteOffsetOrPointer);
        }
    }
<#
    }
#>
}